import ccxt
import pandas as pd
import talib
import time
from config import BINANCE_API_KEY, BINANCE_API_SECRET, symbols, time_interval

# Create a Binance Futures client
exchange = ccxt.binance({
    'apiKey': BINANCE_API_KEY,
    'secret': BINANCE_API_SECRET,
    'enableRateLimit': True,
    'options': {
        'defaultType': 'future',  # Set the default type to futures
    }
})

# Define Stochastic Oscillator parameters
stochastic_k_period = 14
stochastic_d_period = 3

# Track the last order type placed for each symbol
last_order_types = {symbol: None for symbol in symbols}
open_positions = {symbol: None for symbol in symbols}

# Fixed quantity in USDT worth of contracts
fixed_quantity_usdt = 11

# Fetch historical data for futures with Stochastic Oscillator calculation
def fetch_ohlcv(symbol, timeframe, limit):
    ohlcv = exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

    # Calculate Stochastic Oscillator (%K and %D)
    df['slowk'], df['slowd'] = talib.STOCH(df['high'], df['low'], df['close'], fastk_period=stochastic_k_period, slowk_period=3, slowk_matype=0, slowd_period=3, slowd_matype=0)

    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)
    return df

# Main trading function for futures
def ema_strategy():
    while True:
        try:
            for symbol in symbols:
                # Fetch historical data for each symbol
                historical_data = fetch_ohlcv(symbol, time_interval, 200)

                # Check if there's enough data for calculation
                if len(historical_data) < stochastic_d_period:
                    print(f"Not enough data for {symbol}. Waiting for more data...")
                    continue

                # Print Stochastic Oscillator values
                print(f"{symbol} Stochastic Oscillator - %K: {historical_data['slowk'].iloc[-1]}, %D: {historical_data['slowd'].iloc[-1]}")

                # Make trading decisions for each symbol
                if (
                    last_order_types[symbol] != 'LONG' and
                    (historical_data['stochrsi'].iloc[-2] >= historical_data['stochrsi_ma'].iloc[-2] and
                    historical_data['stochrsi'].iloc[-3] <= historical_data['stochrsi_ma'].iloc[-3]) and
                    (historical_data['short_ema'].iloc[-2] >= historical_data['short_ema'].iloc[-3]) and 
                    historical_data['stochrsi'].iloc[-2] <= 0.30
                ):
                    print(f'{symbol} Long Entry Signal')
                    # Close existing short position if any
                    if open_positions[symbol] == 'SHORT':
                        close_short_position(symbol, quantity)
                    # Place a market buy order to enter long position
                    place_market_buy_order(symbol, quantity)
                    open_positions[symbol] = 'LONG'
                    last_order_types[symbol] = 'LONG'

                elif (
                    last_order_types[symbol] == 'LONG' and
                    (historical_data['stochrsi'].iloc[-3] >= historical_data['stochrsi_ma'].iloc[-3] and
                    historical_data['stochrsi'].iloc[-2] <= historical_data['stochrsi_ma'].iloc[-2])
                ):
                    print(f'{symbol} Long Exit Signal')
                    # Close existing long position if short EMA crosses below long EMA
                    close_long_position(symbol, quantity)
                    open_positions[symbol] = None

                elif (
                    last_order_types[symbol] != 'SHORT' and
                    historical_data['stochrsi'].iloc[-2] <= historical_data['stochrsi_ma'].iloc[-2] and
                    historical_data['stochrsi'].iloc[-3] >= historical_data['stochrsi_ma'].iloc[-3] and
                    historical_data['short_ema'].iloc[-2] <= historical_data['short_ema'].iloc[-3] and 
                    historical_data['stochrsi'].iloc[-2] >= 0.70
                ):
                    print(f'{symbol} Short Entry Signal')
                    # Close existing long position if any
                    if open_positions[symbol] == 'LONG':
                        close_long_position(symbol, quantity)
                    # Place a market sell order to enter short position
                    place_market_sell_order(symbol, quantity)
                    open_positions[symbol] = 'SHORT'
                    last_order_types[symbol] = 'SHORT'

                elif (
                    last_order_types[symbol] == 'SHORT' and
                    (historical_data['stochrsi'].iloc[-3] <= historical_data['stochrsi_ma'].iloc[-3] and
                    historical_data['stochrsi'].iloc[-2] >= historical_data['stochrsi_ma'].iloc[-2])
                ):
                    print(f'{symbol} Short Exit Signal')
                    # Close existing short position if short EMA crosses above long EMA
                    close_short_position(symbol, quantity)
                    open_positions[symbol] = None

            # Sleep for some time (e.g., 5 minutes) before checking again
            time.sleep(60)

        except Exception as e:
            print(f'An error occurred: {e}')
            time.sleep(60)  # Wait for a minute before trying again

# Run the trading strategy
ema_strategy()
